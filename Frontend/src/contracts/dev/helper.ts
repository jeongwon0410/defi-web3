import BigNumber from "bignumber.js";
import { useReadContract, useAccount, useReadContracts } from "wagmi";
import AaveOracle from "@/contracts/dev/abi/AaveOracle";
import {
  AssetTitle,
  titleToAddr,
  aaveOracleAddr,
  allAssetTitles,
  aaveDataProviderAddr,
  titleToABI,
  poolAddr,
} from "@/contracts/assets";
import AaveDataProvider from "@/contracts/dev/abi/AaveProtocolDataProvider";
import pool from "@/contracts/dev/abi/Pool";

/**
- The amount of unbacked aTokens of the reserve
- The scaled amount of tokens accrued to treasury that is to be minted
- The total supply of the aToken
- The total stable debt of the reserve
- The total variable debt of the reserve
- The liquidity rate of the reserve
- The variable borrow rate of the reserve
- The stable borrow rate of the reserve
- The average stable borrow rate of the reserve
- The liquidity index of the reserve
- The variable borrow index of the reserve
- The timestamp of the last update of the reserve
 */
export const useAaveReserveDatas = () =>
  useReadContracts({
    contracts: allAssetTitles.map(
      (title) =>
        ({
          ...aave,
          functionName: "getReserveData",
          args: [titleToAddr[title]],
        }) as const,
    ),
  });

/**
 * All standard EIP20 methods are implemented for aTokens,
 * such as balanceOf, transfer, transferFrom, approve, totalSupply etc.
 *
 * `balanceOf` will always return the most up to date balance of the user,
 * which includes their principal balance + the yield generated by the principal balance.
 */
export const useBalanceOf = (title: AssetTitle) => {
  const { address } = useAccount();
  return useReadContract({
    abi: titleToABI[title],
    address: titleToAddr[title],
    functionName: "balanceOf",
    args: address && [address],
  });
};

/**
 * All standard EIP20 methods are implemented for aTokens,
 * such as balanceOf, transfer, transferFrom, approve, totalSupply etc.
 *
 * `balanceOf` will always return the most up to date balance of the user,
 * which includes their principal balance + the yield generated by the principal balance.
 */
export const useBalancesOf = () => {
  const { address } = useAccount();

  return useReadContracts({
    contracts: allAssetTitles.map(
      (title) =>
        ({
          abi: titleToABI[title],
          address: titleToAddr[title],
          functionName: "balanceOf",
          args: address && [address],
        }) as const,
    ),
  });
};

/**
- The current AToken balance of the user
- The current stable debt of the user
- The current variable debt of the user
- The principal stable debt of the user
- The scaled variable debt of the user
- The stable borrow rate of the user
- The liquidity rate of the reserve
- The timestamp of the last update of the user stable rate
- True if the user is using the asset as collateral, else false
 */
export const useUserReserveData = (title: AssetTitle) => {
  const { address } = useAccount();

  return useReadContract({
    ...aave,
    functionName: "getUserReserveData",
    args: address && [titleToAddr[title], address],
  });
};

/**
- The current AToken balance of the user
- The current stable debt of the user
- The current variable debt of the user
- The principal stable debt of the user
- The scaled variable debt of the user
- The stable borrow rate of the user
- The liquidity rate of the reserve
- The timestamp of the last update of the user stable rate
- True if the user is using the asset as collateral, else false
 */
export const useUserReserveDatas = () => {
  const { address } = useAccount();

  return useReadContracts({
    contracts: allAssetTitles.map(
      (title) =>
        ({
          ...aave,
          functionName: "getUserReserveData",
          args: address && [titleToAddr[title], address],
        }) as const,
    ),
  });
};

/**
- The number of decimals of the reserve
- The ltv of the reserve
- The liquidationThreshold of the reserve
- The liquidationBonus of the reserve
- The reserveFactor of the reserve
- True if the usage as collateral is enabled, false otherwise
- True if borrowing is enabled, false otherwise
- True if stable rate borrowing is enabled, false otherwise
- True if reserve is active, false otherwise
- True if reserve is frozen, false otherwise
*/
export const useReserveConfigurationDatas = () =>
  useReadContracts({
    contracts: allAssetTitles.map(
      (title) =>
        ({
          ...aave,
          functionName: "getReserveConfigurationData",
          args: [titleToAddr[title]],
        }) as const,
    ),
  });

export const useAssetPrice = (title: AssetTitle) => {
  const { data } = useReadContract({
    abi: AaveOracle,
    functionName: "getAssetPrice",
    args: [titleToAddr[title]],
    address: aaveOracleAddr,
  });

  return data === undefined
    ? undefined
    : BigNumber(data.toString()).dividedBy(BigNumber(10).pow(8));
};

/** Returns the price of the supported asset in BASE_CURRENCY of the Aave Market.
 * All V3 markets use USD based oracles which return values with 8 decimals. */
export const useAssetPrices = () =>
  useReadContracts({
    contracts: allAssetTitles.map(
      (title) =>
        ({
          abi: AaveOracle,
          functionName: "getAssetPrice",
          args: [titleToAddr[title]],
          address: aaveOracleAddr,
        }) as const,
    ),
  });

/** The total debt (stable + variable) for an asset */
export const useTotalDebts = () =>
  useReadContracts({
    contracts: allAssetTitles.map(
      (title) =>
        ({
          abi: AaveDataProvider,
          functionName: "getTotalDebt",
          args: [titleToAddr[title]],
          address: aaveDataProviderAddr,
        }) as const,
    ),
  });

export const useAllowance = (title: AssetTitle) => {
  const { address } = useAccount();
  return useReadContract({
    abi: titleToABI[title],
    functionName: "allowance",
    address: titleToAddr[title],
    args: address && [address, poolAddr],
  });
};

/**
 * 
- totalCollateralBase: total collateral of the user, in market’s base currency
- totalDebtBase:  total debt of the user, in market’s base currency
- availableBorrowsBase: borrowing power left of the user, in market’s base currency
- currentLiquidationThreshold: liquidation threshold of the user - weighted average of liquidtion threshold of collateral reserves
- ltv: maximum Loan To Value of the user - weighted average of max ltv of collateral reserves
- healthFactor: current health factor of the user

(All V3 markets use USD based oracles which return values with 8 decimals)
 */
export const useUserAccountData = () => {
  const { address } = useAccount();
  return useReadContract({
    abi: pool,
    address: poolAddr,
    functionName: "getUserAccountData",
    args: address && [address],
  });
};

const aave = {
  abi: AaveDataProvider,
  address: aaveDataProviderAddr,
} as const;
